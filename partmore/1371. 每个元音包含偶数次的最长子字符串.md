## 题目描述

给你一个字符串 `s` ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

## 思路

这个题目涉及到的知识点很多：位运算，前缀和，Hash表，状态压缩(这是LeetCode的中等难度？)，自己第一次做也没有想到，看了题解后才慢慢理解的，其实涉及到的知识都不难，但整合到一起就很难想到了。

这里先解释一下我的代码都干了些什么，之后在一步步解释为什么这样想。

```java
public int findTheLongestSubstring(String s) {
    //建立一个Hash表，Hash表存储的是某种状态第一次出现的位置。
    int[] hash = new int[1 << 5];
    //先初始化为-2(-2这里表示的是第一次出现的位置还没确定)
    Arrays.fill(hash, -2);
    //要返回的最大值
    int max = 0;
    //元音字母出现的状态
    int status = 0;
    //状态0出现的第一个位置是-1
    hash[0] = -1;
    //遍历字符串
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        //这里判断c对应的字符，通过异或运算更新对应位置的状态
        switch (c) {
            case 'a' : status ^= 1; break;
            case 'e' : status ^= (1 << 1); break;
            case 'i' : status ^= (1 << 2); break;
            case 'o' : status ^= (1 << 3); break;
            case 'u' : status ^= (1 << 4); break;
        }
        if (hash[status] == -2) { 
            //如果该状态第一次出现的位置还没确定，就更新为当前位置
            hash[status] = i;
        } else { 
            //如果确定了，就计算值。
            max = Math.max(max, i - hash[status]);
        }
    }
    //返回结果
    return max;
}
```

首先我们想，如果只看一个字符出现的次数是否为偶数次，应该可以想到用**前缀和**，统计[0,i]该字符出现的个数；找一个位置j，判断[0,j] - [0,i]是否为偶数，j - i的值就为出现偶数次该字符的长度，然后记录最大的值。但我们需要枚举i和j，时间复杂度仍然是O(n2)。

我们可以想一下，我们没有必要统计它的准确数量，只要知道它是奇数个还是偶数个就好了，然后我们也没必要枚举i和j，只需要知道第一次出现奇数个的位置和最后出现奇数个的位置，第一次出现偶数个的位置和最后出现偶数个的位置，因为奇数减奇数为偶数，偶数减偶数为偶数，所以最长长度就是这两种位置中的最大值。这里就通过题目的出现偶数次这个条件进行了**状态压缩**。

最后扩展到多个字符的情况，一个字符只有奇数和偶数两种状态，而两个字符会有四种状态(a奇数次b奇数次、a偶数次b奇数次、a奇数次b偶数次、a偶数次b偶数次)，五个元音字符会有2的5次方种状态。我们可以通过二进制来表示这些状态，例如偶数次就是0，奇数次就是1，如果出现了某个字符，我们可以让上一个状态和1进行**异或运算**，更新状态。5个字符应该5位二进制数表示，初始为00000。

然后通过一个**Hash表**记录某种状态第一次出现的位置，然后遍历字符串找到最后一次出现的位置，记录最大值即可。对于(00000)这种状态，第一次出现的位置应该为-1，因为遍历字符串是从0开始的，上一个位置为-1，还没有任何字符出现，元音字母出现次数都为0，所以记录为-1。