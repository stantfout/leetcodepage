## 题目描述

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。

## 思路

### 二叉树

如果一个节点是这两个节点的最近公共祖先，那么这两个节点一定分别存在于它们最近公共祖先的左右子树里面。或者p，q这两个节点中一定有一个是它们的最近公共祖先。

```java
private TreeNode res = null;
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    dfs(root, p, q);
    return res;
}

//寻找root的左右节点或者root本身是否包含p,q
private boolean dfs(TreeNode root, TreeNode p, TreeNode q) {
    //剪枝一下
    if (res != null) {
        return false;
    }
    //如果root为null，直接返回false
    if (root == null) {
        return false;
    }
    //左子树是否包含p,q中的一个
    boolean f1 = dfs(root.left, p, q);
    //右子树是否包含p,q中的一个
    boolean f2 = dfs(root.right,p, q);
    //如果root为p或者q,只需要root的左右子树中有一个包含p或q即可
    boolean f3 = (root == p || root == q) && (f1 || f2);
    /**
     *最终判断为true的标准为
	 *  1. root为p或q,它的左右子树中的一个为另一个节点。
	 *  2. root的左右子树分别包含p,q。
	 */
    boolean flag = f3 || (f1 && f2);
    //第一个为true的root节点即为结果，通过一个全局变量存储。
    if (flag) {
        res = root;
    }
    //如果root节点等于p或q，或者它的左右子树包含过p或q，就返回true，否则返回false
    return root == p || root == q || f1 || f2;
}
```